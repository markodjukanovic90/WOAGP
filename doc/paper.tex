\documentclass[runningheads,a4paper]{elsarticle}
% vim: tw=0 wm=0

\setcounter{tocdepth}{3}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{bbm}
\usepackage{environ}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{comment}
\usepackage{placeins}
\usepackage{mathtools}
%\usepackage{algorithmic}
\usepackage{enumitem}
\usepackage[utf8]{inputenc}
%\usepackage{enumite}
%\usepackage{cleveref}
%\usepackage{parskip}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{array}
\usepackage[pdfencoding=auto,psdextra]{hyperref}
\usepackage{booktabs}
\usepackage{bookmark}% faster updated bookmarks
\usepackage{hypcap} % fix the links
\evensidemargin\oddsidemargin
\usepackage{graphicx}
\pagestyle{plain}
\usepackage{xcolor}
\newcommand\ToDo[1]{\textcolor{red}{#1}}
%\bibliographystyle{plainnat}
\usepackage{siunitx}
\usepackage{color}

\usepackage[draft,nomargin,inline]{fixme}
\fxsetface{inline}{\itshape}
\fxsetface{env}{\itshape}
%\fxuselayouts{margin}
%\fxuselayouts{inline}
\fxusetheme{color}

\usepackage{url}
\urldef{\mailsa}\path|{djukanovic, raidl}@ac.tuwien.ac.at,|
\urldef{\mailsb}\path|christian.blum@iiia.csic.es|
\newcommand{\keywords}[1]{\par\aDSvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\usepackage{tikz}
\usetikzlibrary{positioning}
\definecolor{canaryyellow}{rgb}{1.0, 0.94, 0.0}
\definecolor{brightgreen}{rgb}{0.4, 1.0, 0.0}
\definecolor{jazzberryjam}{rgb}{0.65, 0.04, 0.37}

%defining of command

\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
\newcommand\str[1]{\texttt{#1}}
\newcommand\pL[1][]{\ensuremath{p^{\mathrm{L}#1}}}
\newcommand\pR[1][]{\ensuremath{p^{\mathrm{R}#1}}}
\newcommand\qL{\ensuremath{q^\mathrm{L}}}
\newcommand\qR{\ensuremath{q^\mathrm{R}}}
\newcommand\pLH{\ensuremath{\hat{p}^\mathrm{L}}}
\newcommand\pRH{\ensuremath{\hat{p}^\mathrm{R}}}
\newcommand{\Vext}{\ensuremath{V_\mathrm{{ext}}}}
\newcommand\UB{\ensuremath{\mathrm{UB}}}
\newcommand\Sigmand{\ensuremath{\Sigma^\mathrm{nd}}}
\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\theenumii}{\theenumi.\arabic{enumii}.}
\setlength{\leftmarginii}{1.8ex}
\raggedbottom
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

% scaling factor for tables
\newcommand\tabscale{0.8}

\begin{document}

    %\setlength{\parindent}{0pt}  % disallow indentations
    %\numberwithin{table}{1}
    %\mainmatter  % start of an individual contribution

    % first the title is needed
    \title{On Solving the Weighted Orthogonal Art Gallery Problem under regular grid discretization by greedy methods and their hybridizations}

    %
  %  \author{--}
    %

  %  \institute{%$^1$Institute of Logic and Computation, TU Wien,
    %Vienna, Austria,\\
    %	       $^2$ Artificial Intelligence Research Institute (IIIA-CSIC),\\ \normalsize Campus UAB, Bellaterra, Spain \\
    %\institute{Springer-Verlag, Computer Science Editorial,\\
    %Tiergartenstr. 17, 69121 Heidelberg, Germany\\
    %\mailsa\\
    %\mailsb\\
    %\mailsc\\
    %\url{http://www.springer.com/lncs}
    %}
    \begin{abstract}
    In this paper...
    \end{abstract}
    \maketitle


    \section{Introduction}\label{sec:introduction}
     \emph{The Orthogonal Art Gallery Problem} (OAGP) is one of many variants of Art Gallery Problem (AGP). AGP asks for a set of points $G$ of minimal cardinality on some polygon $P$ such that for each point $y \in P$ there is $x \in G$ such that $xy \subset P$.  Set $G$ is called guard set of $P$ and the points from $G$ as guards. The orthogonal AGP consider on arbitrary polygon but whose angles are $90^{\circ}$ and $270^{\circ}$. This problem was stated by Victor  Klee in 1973.~\cite{o1987art}. The problem is motivated from installing the cameras inside a building (or gallery) such that the whole area of the building is covered. Orthogonality constraint naturally comes out from the orthogonality of the walls in buildings.

     Kahn et al. in ~\cite{kahn1983traditional} formulated and proofed that 	$\lfloor \frac{n}{4} \rfloor$ guards are  sufficient to cover an orthogonal polygon with $n$ vertices.  A variant of the OAGP for which we are interested in this study allows only that guards are positioned at the vertices of polygon $P$. Actually, we are looking for minimum vertex guards needed to cover an orthogonal polygon. This restricted problem is known to be NP- hard in ~\cite{schuchardt1995two,katz2008guarding}.

     By discretization $D(P)$ the set of points of the polygon $P$, the art gallery problem can be reduced to the well-known Min Set Cover Problem.\fxnote{Marko: ovdje fali motivacija zasto radimo diskretizaciju poligona} For each vertex of the polygon $P$, a set of points of visibility is determined. In that way, the problem of determining the minimum number of guards covering the entire polygon is reduced to determining the minimum number of subsets of points, such that each point from $D(P)$ is included in at least one of the chosen subsets.



     In ~\cite{ghosh2010approximation} an approximate solution of the minimum vertex guard problem, which can be computed in $O(n^4)$ time and the size of the solution is at most $O(\log n)$ times the optimal, is presented for simple polygon with $n$ vertices. Firstly, this algorithm do a partitioning the polygonal region into convex components and construct sets consisting of these convex components. After that, on these constructed sets Johnsonâ€™s approximation algorithm ~\cite{johnson1974approximation} for the Minimum set-covering problem (MSC) is applied to get solution.

     An anytime algorithm to compute successively better approximations of the optimum to Minimum Vertex Guard is proposed in ~\cite{tomas2003approximation}.  A major idea of this approach is exploring dominance of visibility regions to first detect pieces that are
more difficult to guard. The same problem is solved   in ~\cite{tomas2006visibility} by applying successive approximations from  ~\cite{tomas2003approximation}.

Tozoni et a. ~\cite{tozoni2013practical,tozoni2016algorithm}  presented an exact Integer linear programming  (ILP)-based  algorithm, which iteratively generates upper and lower bounds through the resolution of discretized space of the AGP.

More detailed overview of the results on art gallery problems is out the scope of this paper and can be found in a survey paper  ~\cite{ghosh2010approximation2}.


    Couto et al. presented an exact and efficient algorithm for the Orthogonal Art Gallery Problem in ~\cite{couto2007exact}. The algorithm is divided into two phases. In the preprocessing phase an initial discretization is constructed and the Integer Programming model for solving MSC is applied.  In the solution phase, the discretized instance is iteratively refined and solved, until the solution becomes viable. \fxnote{Marko: ja bih ovdje samo rekao:  Couto et al. an efficient exact algorithm  for OAGP  based on preprocessing and refinement phases of the the discretized instance. }
\subsection{Problem definition}


\subsection{Main contributions}
The main contributions of this paper are:
\begin{itemize}
\item We developed a novel greedy approach which is based on balancing the trade off between the total sum of guards' costs and the total number of not yet covered points from the discretization.
\item We developed a specially designed shaking procedure, which perturbs the current partial solution in such a way that some vertices are replaced with others based on a distance measure.\fxnote{TODO: popraviti}
\item Both an existing and the novel greedy algorithms are hybridized with the proposed shaking procedure and with the ILP
\item We considered different types of weights for our benchmarks, based on a... \fxnote{TODO}
\end{itemize}

     \fxnote{TODO: work on literature approaches}
     %\section{Preliminaries}

     \subsection{Discretization}  \fxerror{TODO: Milan treba da ovo objasni proces transofrmacije, zasto uzimamo ovakav tip diskretizacije, kako se onda problem svodi na SC, da obajsni zasto diskretni grid ne mora dati potpunu pokrivenost poligona -- dvije slike. Proces transfomracije objasniti kratko (mozda i pseudokod ako je moguce da se prikaze)... }

     \section{Exact methods}\fxnote{TODO: Marko}
     \subsection{Integer linear programming method}
     Let us suppose we are given a polygon $P$ and a discretization $D(P)$ of $P$.  Our task is to cover all points from $D(P)$ by some vertices from $P$ such that the sum of their weights is minimized. 
     The problem is related to the known Minimal Weighted Set-Cover (MWSC) problem. 
     Family $\mathcal{F}\subseteq D(P)$ of nonempty sets consists of sets
      $S_i \in \mathcal{F}$ which include point $p \in D(P)$ that is visible from guard $v_i\in V$, that is $pv_i \subset P$.  Note that set $S_i$ includes a point $p_i$ which can also included by some other guard $v_j\in V$, $i \neq j$. In this was, the task is equivalent of  finding a minimum cardinalty cover $\mathcal{C}\subseteq\{S_1,...,S_n\}$ of the set of points $D(P)$, that is
     $$ \bigcup_{C \in \mathcal{C}} C = D(P).$$ The IP  model for the Weighted Set Cover problem is well-known in the literature, and is here adapted for our task as follows:
     \begin{align}
        &\sum_{i=1}^n w_ix_i \longrightarrow \min \\
        &\mbox{s.t.} \\
        &\sum_{j\in V} a_{ij}x_j \geq 1\ (\forall p_i\in D(P)) \label{eq:const-3}\\
        & x_j \in \{0,1\}, j \in V,
     \end{align}
     where
     $a_{ij} = \begin{cases}
          1, p_i \in V(j), \\
          0, \mbox{otherwise}
     \end{cases}$
     and $x_i = \begin{cases}
     	 1, \mbox{ if } \mbox{ the point } p_i \in \mathcal{C},\\
     	 0, \mbox{otherwise},
     \end{cases}$ \\
      where $V(j)$ is the set of all points from $D(P)$ that are visible from $j$-th vertex of $P$.
     Set $Z = \{j \in V\mid x_i=1\}$ represents a solution of the problem w.r.t. discretization $D(P)$ of polygon $P$.
     Constraint~(\ref{eq:const-3}) enforces that any point $p_i \in D(P)$ will be visible from at least one guard from $Z$.

    Introducing the prices into the basic problem can be augmented by the fact that prices of cameras are usually not equal and they are related to their quality (respecting the range of spectrum of view) or due to the fact that installing cameras at some specific corners is much harder than to some other areas. 

      In order to solve this model, we apply a general purpose solver \textsc{Cplex}.
       \subsection{Constraint programming method} An equivalent CP model was implemented and tested by CP Optimizer. In this case,  Constraint~(\ref{eq:const-3}) is transformed into 
       \begin{equation}
           \bigvee_{ j \in V } (a_{ij} \wedge x_j) = 1, 
       \end{equation}
      whereas the other constraints and the objective function are the same like in the above MIP model. 
     \section{Algorithmic Approaches for WOAGP}
     \subsection{Greedy approaches for solving WOAGP}
      Since the WOAGP can be seen as the Weighted Set Cover problem (WSCP) and since the best known heuristics to solve WSCP is an enhanced greedy heuristic, our idea is to transform a WOAGP instance into a WSC problem instance and then
          apply greedy algorithms to solve WOAGP. These algorithms produce a solution of reasonable quality within a short interval of time. Efficiency of such greedy heuristics is related to a greedy criterion utilized to expand current (non-complete, i.e., partial) solution to complete one. Among all candidates (solution components for expansion, that is not-yet-considered guards, we choose one with the smallest greedy value until the solution is complete (i.e., cover all  points from $D(P)$).
          A general pseudocode of Greedy heuristics is given in Algorithm~\ref{alg:greedy}

          \begin{algorithm}[!t]
          	\caption{Greedy Heuristic}\label{alg:greedy}
          	\begin{algorithmic}[1]
          		\State \textbf{Input:} an instance of a problem
          		\State \textbf{Output:} A (feasible) non-expandable solution (or reporting that no feasible solution)
          		\State $s^{P} \gets ()$ \hspace{0.3cm}// partial solution set to empty solution
          		\While{$\text{Extend}(s^{P}) \neq \emptyset$}
          		\State Select component $e \in  \text{Extend}(s^{P})$ \hspace{0.3cm}//\,w.r.t.\  some criterion
          		\State Extend $s^{P}$ by $e$
          		\EndWhile
          	\end{algorithmic}
          \end{algorithm}
     \subsubsection{An existing greedy method}\fxnote{TODO: Milana}
         
    %  \subsection{Greedy Criterion based on Price-per-Unit}
      Concerning the literature for WSC problem~\ref{chvatal1979greedy, lovasz1975ratio}, one of the most efficient greedy heuristic was based on the following greedy rule:
     \begin{align}
     g(s^p, p_i) = \frac{w_{p_i}}{ f(s^p \cup \{p_i\})  - f(s^p)},
     \end{align}
     where $f(s^p) = |\bigcup_{s \in s^p} s |$.
     This heuristic is also a approximation algorithm which ensures $O(\log(n))$ approximation factor.

        \subsubsection{A Novel Greedy Heuristic}\fxnote{TODO: Dragan}
        In this subsection we present a novel greedy function, which is used in the greedy algorithm. Let us introduce a term  ``incorrect point''. For a point from $D(P)$ we say that it is incorrect if it is not covered by any guard from a current partial solution $s^{ps}$. Let denote by $incorrect_{total}$ the total number of incorrect points from discretization $D(P)$ for the current partial solution.  Let $w_{total}$ be the total sum of all weights among all vertices and $|D(P)|$ be total number of discretization set. The greedy function for the given partial solution $s^{ps}$ and the guard $v$ takes into account both the value of the objective function of the WOAGP  applied to the partial solution if $v$ is included in it and the total number of incorrect points, given by the formula:
        \begin{equation}\label{eq:greedyfun2}
				%$$obj(s^{ps}; v)  =    \frac{\sum_{i \in s^{ps} \cup \{v\}\}} w_i}{w_{total}}+ incorrect_{total}$$ 
				g(s^{ps}; v) = \alpha \cdot \sum_{i \in s^{ps} \cup \{v\}} w_i+ \beta \cdot {incorrect_{total}}
		\end{equation}
where $\alpha$ and $\beta$ are positive real parameters.

            Although many combination of parameters $ \alpha $ and $\beta$ may be used, in our investigation we used parameter $\alpha$  only to normalize the sum of prices, i.e. $\alpha = \frac{1}{w_{total}}$ and two values for $\beta$: $\beta = 1$ and $\beta = \frac{1}{|D(P)|}$. Thus, we consider two variants of the greedy function:
                    \begin{equation}\label{eq:greedyfun3}
				g_2(s^{ps}; v)  =  \frac{\sum_{i \in s^{ps} \cup \{v\}\}} w_i}{w_{total}}+ incorrect_{total}
		\end{equation}
and 
        \begin{equation}\label{eq:greedyfun4}
				g_3(s^{ps}; v)  =    \frac{\sum_{i \in s^{ps} \cup \{v\}\}} w_i}{w_{total}}+ \frac{incorrect_{total}}{|D(P)|}
		\end{equation}
            From Equation (\ref{eq:greedyfun3}) one can see that the greedy function $g_2$ mainly depends on the second term, since the value of the first one is not greater than 1. On other words, this function prefers such guards  which inclusion in the partial solution will cover more points. On the other side, if the inclusion of some two guards covers the same number of points, then the function suggest  the guard with lower cost. In the early stage of the greedy algorithm this approach enables that the guards which covers more points are preferable, while in a later stage, when less points remain uncovered, the function prefers the guards with lower cost.


            In the Equation  (\ref{eq:greedyfun4}) the second term is also normalized and the trade off between two terms is more balanced.
            In this case, the algorithm does not  ultimately prefer any of criteria\fxnote{TODO...}
            \begin{itemize}

\item start Greedy with empty solution
			\item in each iteration add such a guard to $s^{ps}$ for which the obj value is minimal
			\item end when $incorrect_{total}$ becomes 0
          \end{itemize}
      Ties occurred in the search are broken by using  price-per-unit heuristic which i stated as follows.
       For each not yet considered guards $p_i$, we assign the region which is visible from $p_i$ by $S(p_j)$. As the next candidate to extend $s^P$, we choose a guard $p^*$ which covers set $V(j)$ by smallest price per unit, among the other candidate to extend $s^P$. More precisely, greedy criterion $g$ is given as:
      \begin{align}
      g(s^p, p_i) = \frac{w_{p_i}}{S_{p_i}},
      \end{align}
      and $p^*$ that minimizes $g(s^p, p^*)$ value is chosen as an extension of the current partial solution.
      In our experimental studies, we found out that this heuristic does not perform well on its own, but presents a reasonable tie-breaking mechanism and is able to boost quality of our greedy heuristics.
     \subsubsection{Partial calculation of objective function}

    \subsubsection{A hybrid of the Greedy and shaking}
    \fxnote{TODO: Ubaciti pricu o shaking $-->$ Dragan?}
    
    
    \subsubsection{A Hybrid of the Greedy + CPLEX}
        CPLEX will soon or later degrades its performance w.r.t. instance size. On the other hand, the later stage of Greedy increase the chance to worsen the final greedy solution.  So it makes sense to combine  partial solutions generated by  Greedy over a few interactions  and then to use CPLEX up to completion of the partial solution. Our approach consists of the following steps:
        \begin{enumerate}
        	\item Run a Greedy method up to $K$ iterations (parameter) to obtain a partial solution $C$ (therefore, $|C| = K$);
        	\item Take solution $C$ and make it complete via. CPLEX model.
        	\begin{itemize}
        		\item CPLEX solves corresponding sub-model which is formed by adding constraints $x_{p_i} = 1$, for all $p_i \in C$ into the existing WOAGP model;
        		\item we obtain a complete solution $C'$;
        	\end{itemize}
            \item return $f(C')$.
        \end{enumerate}

      \begin{comment}

       \noindent \textbf{Improvements of the above method.} The above method can serve as a basic iteration
       of a more advanced techniques like ILP-LNS or CMSA. In this case, methods for destructing the solutions
       has to be proposed.  Underlying idea could be:
       \begin{itemize}
       	    \item remove $N$ guards with the largest costs out of $C'$
       	    \item remove $N$ guards which have a higher amount of points from $D(P)$ covered by other guards, represented by the function
       	    \begin{align}
       	       ratio(i) = \frac{\sum_{v \in V\setminus{ \{i\}}, j \in V(i)} 1_{j \mbox{ is veasible from } v} }{|V(i)|}.
       	    \end{align}
       \end{itemize}
      \end{comment}

     \section{Computational Results}
       We used the instance of the specific OAGP up to a 200 vertices, and assigned the weights to each vertex of polygons. We included two kind of weights into these benchmarks:
       \begin{itemize}
       	  \item \emph{topologically-based benchmarks}. For each vertex $i$ of polygon $P$ let us denote by $l_i$ and $l_{i+1}$ the lengths of edges that comes out of vertex $i$. Then, $w_i := \frac{l_i + l_{i+1}}{2}$. This can be augmented by the fact that if the the arithmetic length of both edges that comes out of vertex $i$ is longer, it is expected that vertex is a guard can see a larger pieces of polygon $P$. This implies that the range of camera $i$ has to be larger, which again means that it has to be of a higher price.
       	 \item \emph{point-based benchmarks:} For each vertex $j$, we consider the number of points in $D(P)$ that are visible from the given vertex $(|V(j)|)$. Based on this number, we assign prices to the vertices on the following way:
       	 \begin{equation}
       	   w_j = n \cdot \frac{|V(j)|}{|D(P)|}, j=1,...,n. 
       	 \end{equation}
       \end{itemize}
     \section{Conclusions and Future Work}



    \bibliographystyle{abbrv}
    \bibliography{bib}


\end{document}
